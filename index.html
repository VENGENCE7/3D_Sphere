<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eclipse Effect 3D Sphere</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-size: 12px;
            opacity: 0.7;
            user-select: none;
        }
    </style>
</head>
<body>
    <div class="info">Drag to rotate â€¢ Scroll to zoom</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.z = 3.5;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        
        // Create dense dot matrix
        function createEclipseSphere(radius) {
            const points = [];
            const latLines = 200;
            const lonLines = 250;
            
            for (let lat = 0; lat <= latLines; lat++) {
                const theta = (lat * Math.PI) / latLines;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                for (let lon = 0; lon <= lonLines; lon++) {
                    const phi = (lon * 2 * Math.PI) / lonLines;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    
                    const x = radius * sinTheta * cosPhi;
                    const y = radius * cosTheta;
                    const z = radius * sinTheta * sinPhi;
                    
                    points.push(x, y, z);
                }
            }
            
            return new Float32Array(points);
        }
        
        // Create geometry
        const radius = 1.5;
        const positions = createEclipseSphere(radius);
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        
        const initialPositions = new Float32Array(positions);
        geometry.setAttribute('initialPosition', new THREE.BufferAttribute(initialPositions, 3));
        
        const randoms = new Float32Array(positions.length / 3);
        for (let i = 0; i < randoms.length; i++) {
            randoms[i] = Math.random();
        }
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));
        
        // Vertex shader for eclipse effect with surface gradients
        const vertexShader = `
            attribute vec3 initialPosition;
            attribute float aRandom;
            
            varying vec3 vColor;
            varying float vIntensity;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying float vDisplacement;
            
            uniform float time;
            
            const float radius = 1.5;
            
            // Create violent cosmic ripple patterns with deep shadows
            float cosmicRipple(vec3 p, float t) {
                // VIOLENT primary waves - much stronger
                float wave1 = sin(p.x * 4.0 + t * 2.5) * cos(p.y * 3.5 - t * 2.0) * 1.2;
                float wave2 = sin(p.z * 5.0 - t * 2.8) * cos(p.x * 4.5 + t * 2.3) * 1.1;
                float wave3 = cos(p.y * 6.0 + t * 1.8) * sin(p.z * 4.0 - t * 2.6) * 1.0;
                
                // Secondary violent ripples
                float ripple1 = sin(p.x * 8.0 + wave1 * 3.0 - t * 3.2) * 0.7;
                float ripple2 = cos(p.y * 7.0 - wave2 * 2.5 + t * 2.9) * 0.6;
                float ripple3 = sin(p.z * 9.0 + wave3 * 2.0 - t * 3.5) * 0.5;
                
                // Chaotic turbulence for violent effect
                float chaos1 = sin(p.x * 15.0 + wave1 * 4.0) * cos(p.y * 12.0 - wave2 * 3.0) * 0.4;
                float chaos2 = cos(p.z * 18.0 - wave3 * 2.5) * sin(p.x * 14.0 + t * 4.0) * 0.3;
                
                // Interference patterns for complex wave interactions
                float interference = sin(wave1 + wave2) * cos(wave2 + wave3) * sin(wave3 + wave1) * 0.8;
                
                return wave1 * 0.35 + wave2 * 0.32 + wave3 * 0.28 + 
                       ripple1 * 0.2 + ripple2 * 0.18 + ripple3 * 0.15 +
                       chaos1 * 0.12 + chaos2 * 0.1 + interference * 0.25;
            }
            
            void main() {
                vec3 pos = initialPosition;
                vec3 normal = normalize(pos);
                
                // Create violent surface ripples
                float t = time * 0.8; // Much faster animation
                float ripple = cosmicRipple(pos, t);
                
                // MUCH stronger displacement for violent waves
                float displacement = ripple * 0.35; // Increased from 0.12 to 0.35
                vec3 displaced = pos + normal * displacement;
                
                // Update normal based on displacement
                vec3 tangent1 = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
                if (length(tangent1) < 0.01) {
                    tangent1 = normalize(cross(normal, vec3(1.0, 0.0, 0.0)));
                }
                vec3 tangent2 = normalize(cross(normal, tangent1));
                
                // Calculate gradient of displacement for normal perturbation
                float epsilon = 0.01;
                vec3 posT1 = pos + tangent1 * epsilon;
                vec3 posT2 = pos + tangent2 * epsilon;
                float rippleT1 = cosmicRipple(posT1, t);
                float rippleT2 = cosmicRipple(posT2, t);
                
                vec3 perturbedNormal = normalize(normal + 
                    tangent1 * (rippleT1 - ripple) * 25.0 + 
                    tangent2 * (rippleT2 - ripple) * 25.0);
                
                vNormal = perturbedNormal;
                vWorldPos = displaced;
                vDisplacement = displacement;
                
                // FIXED WORLD-SPACE Eclipse lighting (doesn't rotate with sphere)
                // Transform displaced position to world space for fixed eclipse effect
                vec4 worldPos4 = modelMatrix * vec4(displaced, 1.0);
                vec3 worldPosition = worldPos4.xyz;
                
                // Fixed eclipse light direction in world space (from upper right)
                vec3 eclipseLight = normalize(vec3(2.0, 1.5, 1.0));
                
                // Calculate lighting based on world-space position for fixed eclipse
                float worldLightIntensity = dot(perturbedNormal, eclipseLight);
                
                // Enhanced shadow casting from wave heights
                float waveHeight = displacement;
                float neighborHeight1 = cosmicRipple(pos + vec3(0.1, 0.0, 0.0), t) * 0.35;
                float neighborHeight2 = cosmicRipple(pos + vec3(0.0, 0.1, 0.0), t) * 0.35;
                float neighborHeight3 = cosmicRipple(pos + vec3(0.0, 0.0, 0.1), t) * 0.35;
                
                // Create shadow occlusion based on neighboring heights
                float shadowOcclusion = 1.0;
                if (neighborHeight1 > waveHeight + 0.1) shadowOcclusion *= 0.6;
                if (neighborHeight2 > waveHeight + 0.1) shadowOcclusion *= 0.7;
                if (neighborHeight3 > waveHeight + 0.1) shadowOcclusion *= 0.65;
                
                // Deep valley shadows
                float valleyShadow = smoothstep(-0.2, 0.0, displacement);
                shadowOcclusion *= (0.3 + valleyShadow * 0.7);
                
                // Apply shadow occlusion to lighting
                worldLightIntensity *= shadowOcclusion;
                
                // Remap for dramatic eclipse effect with deeper shadows
                worldLightIntensity = pow(max(worldLightIntensity * 0.4 + 0.3, 0.0), 2.0);
                
                // Fixed world-space rim lighting for eclipse corona
                vec3 worldViewDir = normalize(cameraPosition - worldPosition);
                float worldRim = 1.0 - abs(dot(perturbedNormal, worldViewDir));
                worldRim = pow(worldRim, 3.0);
                
                // Combine fixed world-space lighting effects
                float finalIntensity = worldLightIntensity + worldRim * 0.2;
                
                // FIXED WORLD-SPACE COLOR GRADIENT (colors stay in fixed positions)
                vec3 black = vec3(0.0, 0.0, 0.0);
                vec3 deepViolet = vec3(0.12, 0.0, 0.30);  // #260059 (main surface color)
                vec3 purple = vec3(0.4, 0.0, 0.8);        // #8000FF (main surface color)
                vec3 magenta = vec3(0.6, 0.0, 0.6);
                vec3 pink = vec3(0.8, 0.1, 0.4);          // #FF1A80
                vec3 hotPink = vec3(1.0, 0.2, 0.4);
                vec3 red = vec3(1.0, 0.1, 0.2);
                vec3 orange = vec3(1.0, 0.33, 0.0);       // #FF5500
                vec3 yellow = vec3(1.0, 0.9, 0.0);
                vec3 brightYellow = vec3(1.0, 1.0, 0.2);  // #FFFF33
                
                // Use WORLD POSITION for fixed eclipse gradient (not rotation dependent)
                vec3 worldNorm = normalize(worldPosition);
                
                // Calculate fixed eclipse position based on world coordinates
                // Yellow only on the extreme right edge (fixed world position)
                float worldX = worldNorm.x;
                float worldY = worldNorm.y;
                float worldZ = worldNorm.z;
                
                // Fixed positional gradient based on world coordinates
                float eclipsePosition = worldX * 0.7 + worldY * 0.3; // Right side gets higher values
                eclipsePosition = (eclipsePosition + 1.0) * 0.5; // Normalize to 0-1
                
                // Dynamic wave-based color modification for purple/black areas
                float waveInfluence = finalIntensity;
                
                // Base color determination by FIXED world position
                vec3 baseColor;
                
                if (eclipsePosition > 0.85) {
                    // EXTREME RIGHT EDGE ONLY - yellow highlights (5-8% of sphere)
                    float t = (eclipsePosition - 0.85) / 0.15;
                    baseColor = mix(orange, brightYellow, t);
                } else if (eclipsePosition > 0.7) {
                    // Right side - orange to red
                    float t = (eclipsePosition - 0.7) / 0.15;
                    baseColor = mix(red, orange, t);
                } else if (eclipsePosition > 0.55) {
                    // Mid-right - pink to red
                    float t = (eclipsePosition - 0.55) / 0.15;
                    baseColor = mix(pink, red, t);
                } else if (eclipsePosition > 0.4) {
                    // Mid - magenta to pink  
                    float t = (eclipsePosition - 0.4) / 0.15;
                    baseColor = mix(magenta, pink, t);
                } else if (eclipsePosition > 0.25) {
                    // Mid-left - purple to magenta (MAIN SURFACE COLORS)
                    float t = (eclipsePosition - 0.25) / 0.15;
                    baseColor = mix(purple, magenta, t);
                } else if (eclipsePosition > 0.1) {
                    // Left side - deep violet to purple (MAIN SURFACE COLORS)
                    float t = (eclipsePosition - 0.1) / 0.15;
                    baseColor = mix(deepViolet, purple, t);
                } else {
                    // Far left - black to deep violet (SHADOWS)
                    float t = eclipsePosition / 0.1;
                    baseColor = mix(black, deepViolet, t);
                }
                
                // DYNAMIC wave response for purple/black main surface areas
                vec3 color = baseColor;
                
                // Purple and black areas respond to waves and shadows
                if (eclipsePosition < 0.4) { // Main surface area
                    // Wave height affects color intensity
                    if (waveInfluence < 0.3) {
                        // Deep shadows in valleys - more black
                        float shadowStrength = 1.0 - (waveInfluence / 0.3);
                        color = mix(color, black, shadowStrength * 0.7);
                    } else if (waveInfluence > 0.7) {
                        // Wave peaks get brighter purple
                        float brightStrength = (waveInfluence - 0.7) / 0.3;
                        color = mix(color, purple * 1.4, brightStrength * 0.5);
                    }
                    
                    // Additional wave shadow casting
                    if (displacement < -0.15) {
                        float deepShadow = smoothstep(-0.15, -0.25, displacement);
                        color = mix(color, black, deepShadow * 0.8);
                    }
                }
                
                // Enhanced violent wave highlights and shadows
                if (displacement > 0.2) {
                    // High wave peaks cast highlights (only in main surface areas)
                    if (eclipsePosition < 0.4) {
                        float highlightBoost = smoothstep(0.2, 0.35, displacement);
                        color = mix(color, purple * 1.6, highlightBoost * 0.4);
                    }
                } else if (displacement < -0.1) {
                    // Deep wave valleys create intense shadows
                    float valleyDepth = smoothstep(-0.1, -0.3, displacement);
                    color = mix(color, black, valleyDepth * 0.9);
                    
                    // Extra dark for very deep valleys
                    if (displacement < -0.2) {
                        float extraDark = smoothstep(-0.2, -0.35, displacement);
                        color = mix(color, vec3(0.0), extraDark * 0.5);
                    }
                }
                
                vColor = color;
                vIntensity = finalIntensity;
                
                // Screen position
                vec4 mvPosition = modelViewMatrix * vec4(displaced, 1.0);
                
                // Dynamic dot sizing
                float baseSize = 2.5;
                float sizeVariation = 1.0 + abs(ripple) * 0.2;
                float intensitySize = 0.8 + finalIntensity * 0.4;
                
                gl_PointSize = baseSize * sizeVariation * intensitySize * (300.0 / -mvPosition.z);
                gl_PointSize = min(gl_PointSize, 8.0);
                
                gl_Position = projectionMatrix * mvPosition;
            }
        `;
        
        // Fragment shader
        const fragmentShader = `
            varying vec3 vColor;
            varying float vIntensity;
            varying vec3 vNormal;
            varying vec3 vWorldPos;
            varying float vDisplacement;
            
            void main() {
                vec2 center = gl_PointCoord - vec2(0.5);
                float dist = length(center);
                
                if (dist > 0.5) discard;
                
                float alpha = smoothstep(0.5, 0.35, dist);
                
                vec3 dotColor = vColor;
                
                // Add glow to bright areas
                if (vIntensity > 0.7) {
                    float glow = 1.0 - dist * 1.5;
                    glow = pow(max(glow, 0.0), 2.0);
                    dotColor += vColor * glow * 0.4;
                    
                    // Corona effect for very bright spots
                    if (vIntensity > 0.9) {
                        float corona = smoothstep(0.5, 0.0, dist);
                        dotColor += vec3(1.0, 0.9, 0.7) * corona * 0.2;
                    }
                }
                
                // Darken shadow areas more
                if (vIntensity < 0.3) {
                    dotColor *= (0.5 + vIntensity);
                }
                
                gl_FragColor = vec4(dotColor, alpha);
            }
        `;
        
        const material = new THREE.ShaderMaterial({
            vertexShader,
            fragmentShader,
            uniforms: {
                time: { value: 0 }
            },
            transparent: true,
            depthTest: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        
        const eclipseSphere = new THREE.Points(geometry, material);
        scene.add(eclipseSphere);
        
        // Mouse interaction
        let targetRotationX = 0.15;
        let targetRotationY = -0.3;
        let isMouseDown = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        
        function onMouseMove(event) {
            if (isMouseDown) {
                const deltaX = event.clientX - previousMouseX;
                const deltaY = event.clientY - previousMouseY;
                
                targetRotationY += deltaX * 0.005;
                targetRotationX += deltaY * 0.005;
                
                targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
            }
            
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }
        
        function onMouseDown(event) {
            isMouseDown = true;
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }
        
        function onMouseUp() {
            isMouseDown = false;
        }
        
        function onTouchMove(event) {
            if (event.touches.length === 1) {
                event.preventDefault();
                const touch = event.touches[0];
                const deltaX = touch.clientX - previousMouseX;
                const deltaY = touch.clientY - previousMouseY;
                
                if (previousMouseX !== 0 && previousMouseY !== 0) {
                    targetRotationY += deltaX * 0.005;
                    targetRotationX += deltaY * 0.005;
                    targetRotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRotationX));
                }
                
                previousMouseX = touch.clientX;
                previousMouseY = touch.clientY;
            }
        }
        
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                previousMouseX = touch.clientX;
                previousMouseY = touch.clientY;
            }
        }
        
        function onTouchEnd() {
            previousMouseX = 0;
            previousMouseY = 0;
        }
        
        function onWheel(event) {
            camera.position.z += event.deltaY * 0.002;
            camera.position.z = Math.max(2, Math.min(5, camera.position.z));
        }
        
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('touchmove', onTouchMove, { passive: false });
        document.addEventListener('touchstart', onTouchStart);
        document.addEventListener('touchend', onTouchEnd);
        document.addEventListener('wheel', onWheel);
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        window.addEventListener('resize', onWindowResize);
        
        const clock = new THREE.Clock();
        let currentRotationX = 0.15;
        let currentRotationY = -0.3;
        
        function animate() {
            requestAnimationFrame(animate);
            
            const elapsedTime = clock.getElapsedTime();
            
            material.uniforms.time.value = elapsedTime;
            
            currentRotationX += (targetRotationX - currentRotationX) * 0.1;
            currentRotationY += (targetRotationY - currentRotationY) * 0.1;
            
            if (!isMouseDown) {
                targetRotationY += 0.0008;
            }
            
            eclipseSphere.rotation.x = currentRotationX;
            eclipseSphere.rotation.y = currentRotationY;
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>